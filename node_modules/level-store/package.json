{
  "name": "level-store",
  "description": "A streaming storage engine based on LevelDB.",
  "version": "3.9.1",
  "repository": {
    "type": "git",
    "url": "git://github.com/juliangruber/level-store.git"
  },
  "homepage": "https://github.com/juliangruber/level-store",
  "main": "index.js",
  "scripts": {
    "test": "tap test/*.js"
  },
  "dependencies": {
    "through": "~2.2.7",
    "duplexer": "~0.1.1",
    "monotonic-timestamp": "~0.0.8",
    "level-delete-range": "~0.1.0",
    "level-capped": "~0.0.4",
    "level-peek": "~1.0.6",
    "level-live-stream": "~1.4.4",
    "level-fix-range": "~1.1.2"
  },
  "devDependencies": {
    "tap": "*",
    "rimraf": "~2.2.0",
    "level": "~0.10.0",
    "ben": "0.0.0"
  },
  "keywords": [
    "leveldb",
    "levelup",
    "stream",
    "persistent"
  ],
  "author": {
    "name": "Julian Gruber",
    "email": "mail@juliangruber.com",
    "url": "http://juliangruber.com"
  },
  "license": "MIT",
  "readme": "# level-store\n\nA streaming storage engine based on [LevelDB](https://github.com/rvagg/node-levelup). It is\n\n* **faster** than the `fs` module\n* **local** in contrast to Amazon S3\n* **streaming** from the first byte in contrast to Amazon S3\n* **appending** values when desired\n* **resuming** reads when something failed\n* **in-process**\n\n![LevelDB Logo](https://twimg0-a.akamaihd.net/profile_images/3360574989/92fc472928b444980408147e5e5db2fa_bigger.png)\n\n[![Build Status](https://travis-ci.org/juliangruber/level-store.png)](https://travis-ci.org/juliangruber/level-store)\n\nOnly need in-memory persistence and no resuming? Check out [enstore](https://github.com/juliangruber/enstore).\n\n***\n\n## Usage\n\nStore a file in LevelDB under the key `file` and read it out again:\n\n```js\nvar levelup = require('level');\nvar Store = require('level-store');\nvar fs = require('fs');\n\nvar store = Store(levelup('/tmp/level-store'));\n\nfs.createReadStream(__dirname + '/file.txt')\n  .pipe(store.createWriteStream('file'))\n  .on('close', function () {\n    // file.txt is stored in leveldb now\n    store.createReadStream('file').pipe(process.stdout);\n  });\n```\n\n## Live persistence\n\nIf you want to persist a stream and read from it at the same time, without reading what didn't get stored yet,\nyou can do it like this:\n\n```js\n// first start reading from the stored version\nstorage.createReadStream('stream', { live: true }).pipe(someWhere);\n// then put your stream into the store\nstream.pipe(storage.createWriteStream('stream'));\n```\n\n## Resuming\n\nWhen reading fails you might not want to start over again completely but rather\nresume after the last chunk you received. First, pass `index: true` as an\noption so you don't only get the stored chunks but also their index in the\nstore:\n\n```js\nstore.createReadStream('file', { index: true }).on('data', console.log);\n// => { index: 1363783762087, data : <Buffer aa aa> }\n```\n\nNow you only need store the timestamp of the last read chunk in a variable and you can\nresume reading after an error, passing `{ gt: index }`:\n\n```js\nstore\n  .createReadStream('file', { gt: 1363783762087, index: true })\n  .on('data', console.log);\n// => { index: 1363783876109, data : <Buffer bb bb> }\n```\n\n## Indexes\n\nYou can choose from several indexing mechanisms, which are from fastest to\nslowest:\n\n* **timestamp**: The default index. Uses timestamps of when a chunk was written.\n**Fast** and already enough for resuming. Activate with\n`Store(db, { index : 'timestamp' })`.\n* **chunks**: The index is the number of chunks already written, starting at `0`.\nActivate with `Store(db, { index : 'chunks' })`.\n* **TODO**: **bytelength**: The index is the bytelength of what has already been written\nunder the given `key`. **Slow**, but very flexible. Activate with\n`Store(db, { index : 'bytelength' })`.\n\n## Capped streams\n\nIf you don't want your stream to grow infinitely and it's ok to cut old parts\noff, use `{ capped : x }` to limit to stream to `x` chunks:\n\n```js\nstore.createWriteStream('file', { capped : 3 }).write('...');\n```\n\n## API\n\n### Store(db[, opts])\n\nReturns a `level-store` instance.\n\n`db` is **an instance of LevelUp**.\n\nIf `opts.index` is set, that indexing mechanism is used intead of the\ndefault one (`timestamp`).\n\n### store#createReadStream(key[, opts])\n\nA readable stream that replays the stream stored at `key`.\n\nPossible `options` are:\n\n* `index (Boolean|String)`: If `true`, don't emit raw chunks but rather objects having\n`index` and `data` fields. If a `String`, override the index passed to `Store()`.\n* `gt (Number|String)`: Emit chunks that have been stored after the given position.\n* `gte (Number|String)`:  Emit chunks that have been stored at or after the given position.\n* `lt (Number|String)`: Emit chunks that have been stored before the given position.\n* `lte (Number|String)`:  Emit chunks that have been stored at or before the given position.\n* `live (Boolean)`: If `true`, the stream will stay open, emitting new data as it comes in.\n* `reverse (Boolean)`: If `true`, chunks will be emitted in reverse order.\n* `limit (Number)`: Receive max. `limit` chunks.\n\n### store#createWriteStream(key[, opts])\n\nA writable stream that persists data written to it under `key`. If something exists under `key`\nalready it will be deleted.\n\nPossible `options` are:\n\n* `append (Boolean)`: If `true`, possibly already existing data stored under `key` will be appended\nrather than replaced.\n* `capped (Number)`: If set, cap the stream to `x` chunks.\n* `index (String)`: Override the index passed to `Store()`.\n\n### store#createKeyStream(opts)\n\nA readable stream that emits all the keys of all streams that are stored.\n\nPossible `options` are:\n\n* `reverse (Boolean)`\n\n### store#get(key[, opts], cb)\n\nAsync version of `createReadStream`.\n\n### store#set(key, value[, opts], cb)\n\nAsync version of `createWriteStream`.\n\n### store#keys(cb)\n\nAsync version of `createKeyStream`, without reverse sorting capability.\n\n### store#delete(key[, cb])\n\nDelete everything stored under `key`. _Returns_ an error if nothing was stored\nunder `key`.\n\n### store#reset(key[, cb])\n\nDelete everything stored under `key`. _Doesn't return_ an error if nothing was stored\nunder `key`.\n\n### store#exists(key, cb)\n\nCheck if `key` exists and call `cb` with `(err, exists)`.\n\n### store#head(key[, opts], cb)\n\nGet the last chunk stored under `key`. `opts` are treated like in\n`db#createReadStream`. `cb` gets called with `(err, chunk)`.\n\n### store#append(key, value[, opts][, cb])\n\nSugar for appending just one `value` to `key`.\n\nIf `opts.index` is set that overrides the index passed to `Store()`.\n\n## Installation\n\nWith [npm](http://npmjs.org) do\n\n```bash\n$ npm install level-store\n```\n\n## License\n\nCopyright (c) 2013 Julian Gruber &lt;julian@juliangruber.com&gt;\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/juliangruber/level-store/issues"
  },
  "_id": "level-store@3.9.1",
  "dist": {
    "shasum": "a5108748496e9c395d9ed2107a5895365f1f43eb"
  },
  "_from": "level-store@",
  "_resolved": "https://registry.npmjs.org/level-store/-/level-store-3.9.1.tgz"
}
